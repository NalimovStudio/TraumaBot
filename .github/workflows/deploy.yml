name: Deploy to VPS

on:
  push:
    branches: [ main, dev_arsen, dev_red, dev_arsen_feat, dev_red_feat ]
  workflow_dispatch:

jobs:
  test:
    # в тестах на машине гитхаба клонируется проект и запускаются автотесты
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install dependencies with Poetry
        run: |
          pip install poetry
          
          poetry config virtualenvs.create true
          poetry config virtualenvs.in-project true
          
          poetry install --no-interaction --no-ansi

      - name: Create test .env file
        run: |
          cat > .env << 'EOF'
          # Test Environment Configuration
          DB_DRIVER=${{ secrets.DB_DRIVER }}
          DB_SYSTEM=${{ secrets.DB_SYSTEM }}
          DB_HOST=localhost
          DB_PORT=5432
          DB_NAME=test_db
          DB_USER=test_user
          DB_PASSWORD=test_password
          
          REDIS_HOST=localhost
          REDIS_PORT=6379
          REDIS_PASSWORD=test
          REDIS_DATABASE=1
          
          TELEGRAM_TOKEN=test_token
          ASSISTANT_API_KEY=test_key
          
          ENVIRONMENT=test
          LOG_LEVEL=DEBUG
          EOF

      - name: Run unit tests with Poetry
        run: |
          poetry run pytest tests/ -v --tb=short

  deploy:
    # Deploy to (TEST | PROD) VDS
    # environment depends on github.ref
    runs-on: ubuntu-latest
    needs: test
    if: needs.test.result == 'success'
    environment:
      name: ${{ contains(github.ref, 'dev_') && 'staging' || 'production' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          echo "${{ secrets.SSH_PRIVATE_KEY }}
          echo "${{ secrets.SSH_HOST }}

          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/github_action_key
          chmod 600 ~/.ssh/github_action_key

          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Copy files with rsync
        run: |
          echo "Copying files with rsync..."
          rsync -avz --delete \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='__pycache__' \
            --exclude='.env' \
            --exclude='.venv' \
            -e "ssh -i ~/.ssh/github_action_key -o StrictHostKeyChecking=no" \
            ./ \
            ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:~/app/TraumaBot/

      - name: Create production .env file on server
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/github_action_key ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} << 'EOF'
            cd ~/app/TraumaBot
            echo "DB_DRIVER=${{ secrets.DB_DRIVER }}" > .env
            echo "DB_SYSTEM=${{ secrets.DB_SYSTEM }}" >> .env
            echo "DB_HOST=${{ secrets.DB_HOST }}" >> .env
            echo "DB_PORT=${{ secrets.DB_PORT }}" >> .env
            echo "DB_NAME=${{ secrets.DB_NAME }}" >> .env
            echo "DB_USER=${{ secrets.DB_USER }}" >> .env
            echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env
            
            echo "REDIS_HOST=${{ secrets.REDIS_HOST }}" >> .env
            echo "REDIS_PORT=${{ secrets.REDIS_PORT }}" >> .env
            echo "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}" >> .env
            echo "REDIS_DATABASE=${{ secrets.REDIS_DATABASE }}" >> .env
          
            echo "TELEGRAM_TOKEN=${{ secrets.TELEGRAM_TOKEN }}" >> .env
            echo "ASSISTANT_API_KEY=${{ secrets.ASSISTANT_API_KEY }}" >> .env
          
            echo "YOOKASSA_WEBHOOK_URL=${{ secrets.YOOKASSA_WEBHOOK_URL }}" >> .env
            echo "WEB_HOST=${{ secrets.WEB_HOST }}" >> .env
            echo "WEB_PORT=${{ secrets.WEB_PORT }}" >> .env
            echo "DOMAIN=${{ secrets.DOMAIN }}" >> .env
          
            echo "TELEGRAM_WEBHOOK_URL=${{ secrets.TELEGRAM_WEBHOOK_URL }}" >> .env
            echo "TELEGRAM_WEBHOOK_SECRET=${{ secrets.TELEGRAM_WEBHOOK_SECRET }}" >> .env
          
            echo "STORE_ID=${{ secrets.STORE_ID }}" >> .env
            echo "STORE_TOKEN=${{ secrets.STORE_TOKEN }}" >> .env
            
            if [ "${{ github.ref }}" = "refs/heads/main" ]; then
              echo ENVIRONMENT=development >> .env
              echo DOCS_ENABLE=False >> .env
            else
              echo ENVIRONMENT=staging >> .env
              echo DOCS_ENABLE=True >> .env

            fi
            echo LOG_LEVEL=INFO >> .env
          EOF

      - name: Determine compose file
        id: compose
        run: |
          COMPOSE_FILE="docker-compose.staging.yml"
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            COMPOSE_FILE="docker-compose.prod.yml"
          fi
          
          echo "COMPOSE_FILE=$COMPOSE_FILE" >> $GITHUB_OUTPUT
          echo "Selected: $COMPOSE_FILE"

      - name: Deploy with Docker Compose with Cleanup (with overcommit check for Staging)
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/github_action_key ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} <<- 'EOF'
            cd ~/app/TraumaBot
          
            # Cleanup docker cache
            docker builder prune -f -a
            docker image prune -f -a
          
            docker-compose -f ${{ steps.compose.outputs.COMPOSE_FILE }} down
            docker-compose -f ${{ steps.compose.outputs.COMPOSE_FILE }} pull
            docker-compose -f ${{ steps.compose.outputs.COMPOSE_FILE }} build --no-cache
            docker-compose -f ${{ steps.compose.outputs.COMPOSE_FILE }} up -d
                  
            sleep 15
            echo "=== Container status ==="
            docker-compose -f ${{ steps.compose.outputs.COMPOSE_FILE }} ps
            echo "=== Recent logs ==="
            docker-compose -f ${{ steps.compose.outputs.COMPOSE_FILE }} logs --tail=15
          EOF
      - name: Run Alembic migrations
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/github_action_key ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} << 'EOF'
            cd ~/app/TraumaBot
            docker exec fastapi poetry run alembic upgrade head
          EOF
